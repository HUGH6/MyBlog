---
title: java内存模型
date: 2019-10-24 21:35:25
id: 201911010101
tags:
	java
categories:
	[java,虚拟机]
---



java虚拟机执行java程序时，会把他管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。

<!-- more -->

## 一、Java内存区域

### 1.1 运行时数据区域

**程序计数器**

程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。

在虚拟机的概念模型里（仅是概念模型，不同虚拟机可能会通过一些更高效的方式实现），字节码解释器工作时就是通过改变该计数器的值来取下一条需要执行的字节码。

由于java虚拟机多线程是通过线程轮流切换分配处理器来实现，任何时刻一个处理器只会运行一个线程，所以，为了线程切换后能恢复到正确执行位置，每个线程都需要一个程序计数器，各线程计数器互不影响。

这类内存区域被称为“线程私有”内存。

若线程执行java方法，则计数器记录虚拟机字节码地址。如果执行native方法，则计数器为空（undefined）。

该区域是唯一一个没规定任何OutOfMemoryError的方法。

**java虚拟机栈**

java虚拟机栈也是线程私有的，其生命周期与线程相同。

虚拟机栈描述了java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于保存局部变量表、操作数栈、动态链接、方法出口等信息。

每个方法从调用至执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型。

局部变量表所需内存空间在编译期间完成分配。当进入一个方法时，其需要在帧中分配多大的局部变量空间是完全确定的，方法运行期间不会改变局部变量表的大小。

Java虚拟机栈上规定了两种异常状况：

* 线程请求的栈深度大于虚拟机运行的深度，抛出StackOverflowError异常
* 虚拟机栈一般可以动态扩展，如果扩展时无法申请到足够内存，抛出OutOfMemoryError异常。

**本地方法栈**

发挥作用与 虚拟机栈类似，但本地方法栈是为虚拟机使用的native方法服务。

本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。

**java堆**

java堆是java虚拟机所管理的内存中最大的一块。

Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。

此内存区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存。java堆是垃圾收集管理的主要区域。

根据java虚拟机规范，java堆可以处于物理上不连续的内存空间中，只要逻辑上实连续的即可。在实现时，即可实现成固定大小，也可是可扩展的。如果在堆中没有内存完成实例分配，并且堆无法再扩展时，将抛出OutOfMemoryError异常。

**方法区**

方法区与java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

**运行时常量池**

运行时常量池是方法区的一部分。

Class文件中除了类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。

java虚拟机对Class文件的每一部分的格式有严格规定，符合规范才能被虚拟机认可、装载和执行，但对运行时常量池，规范没有做任何细节的要求。

运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，java语言并不要求常量一定只有编译期能生成（加载Class文件中常量池的内容），运行时也可将新常量放入池中。（例如String类的intern（）方法）。

常量池无法申请到内存时抛出OutOfMemoryError异常。

**直接内存**

直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。

但该部分内存也被频繁使用，也可能导致OutOfMemoryError异常。



## 二、虚拟机在java堆中对象分配、布局和访问过程

以HotSpot虚拟机为例。

### 2.1 对象创建

语言层面，创建对象使用new关键字，在虚拟机中，创建对象（普通对象，不包括数组和Class对象）的过程如下：

* 虚拟机遇到一个new指令，首先将去检查该指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，那必须先执行相应的类加载过程。
* 类加载检查通过后，接下来虚拟机将为新对象分配内存。内存所需内存大小在类加载完成后便可完全确定。为对象分配空间的任务等同于把一块确定大小的内存从内存中划分出来。
* 假设java堆内存绝对规整，采用“指针碰撞”方式分配内存。（移动使用/空闲内存分界点指示器指针分配内存）
* 假设java堆内存不规整，采用“空闲列表”方式分配内存。（使用列表记录使用/空闲内存情况，分配内存后更新列表）

一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使仅修个一个指针指向的位置，并发情况下也不是线程安全的。有两种分配方案：

* 对分配内存空间的动作进行同步处理。（虚拟机实际使用CAS+失败重试保证操作的原子性）
* 把内存分配的动作按线程划分在不同的空间中进行，即每个线程在java堆中预先分配一个小块内存，称为本地线程分配缓冲（TLAB）。

内存分配完后，虚拟机需要将分配的内存空间初始化为零值（不包括对象头），该操作保证了对象编码时不赋初值也可直接使用。

接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄信息等。这些信息放在对象的对象头中。

这时，从虚拟机视角看，对象已产生。但从java程序视角看，对象创建刚开始，<init>方法没有执行，所有字段都还是零值。执行new之后，接着会执行<init>方法，把对象按照程序员的语言进行初始化。

## 三、对象的内存布局

以HotSpot虚拟机为例，对象在内存中存储的布局分为3个区域：对象头、实例数据和对齐填充。

**对象头**

对象头包括两个部分信息：

* 第一部分：用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等，称为“Mark Word”。Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，会根据对象状态复用自己的存储空间。
* 第二个部分：类型指针，即对象指向它的类元数据的指针，虚拟机通过这个确定这个对象是哪个类的实例。（并非所有虚拟机都实现这个指针，查找对象元数据信息并不一定要经过对象本身）

**实例数据**

实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。

<u>无论是从父类集成还是子类中定义的，都需要记录</u>。

这部分的存储顺序会受虚拟机默认的分配策略参数和字段在java源码中的定义顺序影响。

**对齐填充**

不是必然存在的，也没有特别含义，仅做占位符。

HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以需要填充对齐。

## 四、对象的访问定位

java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以，对象访问方式取决于虚拟机具体实现。

主流有使用句柄和直接指针两种。

* 使用句柄访问：java堆会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。句柄中包含了对象实例数据与类型数据各自的具体地址信息。
* 直接指针访问：reference中存储的直接就是对象地址。

两种方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，而对象被移动时只会改变句柄中的实例数据指针，而reference本身不用修改。

使用直接地址访问的最大好处就是速度更快。

